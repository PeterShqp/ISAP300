/*
 * TopoManager.cpp
 *
 *  Created on: 2013-7-12
 *      Author: Administrator
 */

#include "TopoManager.h"
#include "PriPacket.h"
#include "DeviceComponent.h"
#include "DeviceAttribute.h"
#include "NMPort.h"
#include <string.h>
#include "SwitchPort.h"
#include "SwitchPortInner.h"
#include <stdio.h>
#include "os.h"
#include "InnerDCCManager.h"

TASK void taskTopoAging(void);

TopoPkt::TopoPkt(uint32 head, uint32 belongPort) {
	memcpy( &strPkt[4], PriPacket::multicastAddress, 6);
	DeviceComponent::getDeviceAttribute().getDeviceMac(&strPkt[10]);
	DeviceComponent::getDeviceAttribute().getDeviceIP(&strPkt[20]);
	DeviceComponent::getDeviceAttribute().getDeviceIPMask(&strPkt[24]);
	tag.sn = head;
	memcpy(tag.decMAC, PriPacket::multicastAddress, 6);
	memcpy(tag.srcMAC, &strPkt[10], 6);
	setSndPort(belongPort);
}
TopoPkt::~TopoPkt() {

}

PriPacket* TopoPkt::getPriPacket(void) {
	LAYER2FRAME* f = alloc_Eth_mem(pktSize-4);
	memcpy(f->frame, &strPkt[4], pktSize-4);
	return new PriPacket(tag, 0, f);

}

uint8 TopoManager::Topoing = 0;
enum {TopoTimeOut = 10};

TopoManager::TopoManager() {
}

TopoManager::~TopoManager() {
}

void TopoManager::sendTopoPkt() {
    uint32 priHead = 0x80000000;
	NMPort* p = NMPort::getFirstInstance();
	while( p ) {
        TopoPkt* pkt = new TopoPkt(priHead++, p->getUID());

		SwitchPortInner* port = p->getInnerPort();
		if( port ) {
		    PriPacket* pk = pkt->getPriPacket();
		    if( pk ) {
//		        p->setSndDCCChannel(port);
		        port->outputAPacket(*pk);
		    }
		}
        delete pkt;
		p = NMPort::getNextInstance(p->getUID());
	}
}

/*
 * 发起拓扑搜索 清除之前的拓扑信息。 两次发起拓扑搜索的时间间隔最小为10s
 */
void TopoManager::startTopoSearch() {
    if( Topoing ) {
        printf("\n!!!Topo search have been started!!!\n");
    }
    else {
        Topoing = 10;
        NMPort* rch = NMPort::getFirstInstance();
        uint8 data[4] = {0};
        while( rch ) {
            rch->setUpStreamIP(data);
            rch->setUpStreamIpMask(data);
            rch->setUpStreamPortUid(0);
            rch = NMPort::getNextInstance(rch->getUID());
        }
        sendTopoPkt();
        os_tsk_create(taskTopoAging, P_Agint_MAC);
    }
}


void TopoManager::proccessTopoSearch(PriPacket& p) {
    if( ifMyPacket(p) ) {
        p.deletePacket();
        return;
    }
    if( Topoing == 0 ) {
        startTopoSearch();
    }
	uint16 len = 0;
	uint8* data = p.getStdStream(&len);
	if( data == 0 || len != 24 )  {
	    p.deletePacket();
		return;
	}
	/* ����������Ϣ */
	SwitchPortInner* port = (SwitchPortInner*)SwitchPort::getSwitchPort(p.getSourcePort());
	if( port ) {
		NMPort* ch = p.getRcvNMPort();
		if( ch ) {
			uint32 uid = (data[12] << 24) | (data[13] << 16) | (data[14] << 8) | (data[15] << 0);
			ch->setUpStreamPortUid(uid);
			ch->setUpStreamIP(&data[16]);
			ch->setUpStreamIpMask(&data[20]);
//			InnerDCCManager::instance().processRemoteDevice(&data[16], ch); //用来ch自动分组
		}
	}
	p.deletePacket();
}

bool TopoManager::ifMyPacket(PriPacket& pkt) {
    uint8 myMAC[6] =  {0};
    DeviceComponent::getDeviceAttribute().getDeviceMac(myMAC);
    uint8* mac = pkt.getSrcMAC();
    for (int i = 0; i < 6; ++i) {
        if( myMAC[i] != mac[i] ) {
            return false;
        }
    }
    return true;
}

TASK void taskTopoAging() {

    while( 1 ) {
        os_dly_wait(100);
        if( --TopoManager::Topoing == 0 ) {

            os_tsk_delete_self();
        }
    }
}

